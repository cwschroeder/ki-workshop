# Speckit Constitution

## Code Quality Principles

### Readability and Maintainability
- Code must be self-documenting with clear, descriptive variable and function names
- Complex logic must include explanatory comments describing the "why" not the "what"
- Functions should have a single, well-defined responsibility
- Maximum function length: 50 lines (excluding comments)
- Maximum file length: 500 lines
- Avoid deep nesting (max 3 levels of indentation)

### Type Safety
- All TypeScript code must use strict mode
- Avoid `any` types except in extreme edge cases with documented justification
- Use explicit type annotations for function parameters and return values
- Leverage discriminated unions for complex state management
- Define interfaces and types in dedicated type definition files when shared across modules

### Security
- Never commit secrets, API keys, or credentials to version control
- Sanitize all user inputs to prevent injection attacks
- Use parameterized queries for database operations
- Implement proper authentication and authorization checks
- Follow OWASP Top 10 security guidelines
- Validate and sanitize data at system boundaries

### Error Handling
- All async operations must have proper error handling
- Use typed errors with meaningful error messages
- Log errors with sufficient context for debugging
- Fail fast and provide clear error messages to users
- Never silently swallow errors

### Dependencies
- Keep dependencies minimal and well-justified
- Regularly update dependencies to patch security vulnerabilities
- Document why each dependency is needed
- Prefer standard library solutions over external dependencies when practical

## Testing Standards

### Test Coverage
- Minimum 80% code coverage for all modules
- 100% coverage for critical business logic and security-sensitive code
- All public APIs must have corresponding tests

### Test Organization
- Follow the Arrange-Act-Assert pattern
- One assertion per test when possible
- Use descriptive test names that describe the expected behavior
- Group related tests using describe/context blocks
- Keep test files co-located with source files (e.g., `component.test.ts` next to `component.ts`)

### Test Types
- Unit tests: Test individual functions and components in isolation
- Integration tests: Test interactions between modules
- End-to-end tests: Test complete user workflows for critical paths
- Performance tests: Verify performance requirements are met

### Test Quality
- Tests must be deterministic and not flaky
- Tests should not depend on external services (use mocks/stubs)
- Tests must run quickly (unit tests < 100ms, integration tests < 1s)
- Tests must clean up after themselves (no side effects)
- Mock external dependencies appropriately

### Continuous Testing
- All tests must pass before merging to main branch
- Run tests automatically on every commit via CI/CD
- Monitor test execution time and optimize slow tests

## User Experience Consistency

### Design System
- Follow established design system guidelines
- Use consistent spacing, colors, and typography throughout the application
- Maintain a component library for reusable UI elements
- Document UI patterns and components in Storybook or equivalent

### Accessibility
- Meet WCAG 2.1 Level AA standards minimum
- All interactive elements must be keyboard accessible
- Provide ARIA labels for screen readers
- Maintain minimum contrast ratios (4.5:1 for normal text, 3:1 for large text)
- Support common assistive technologies

### Responsive Design
- Support mobile, tablet, and desktop viewports
- Test on multiple browsers (Chrome, Firefox, Safari, Edge)
- Use relative units (rem, em, %) instead of fixed pixels where appropriate
- Implement progressive enhancement

### Interaction Patterns
- Provide immediate feedback for user actions
- Use consistent navigation patterns throughout the application
- Implement loading states for async operations
- Show clear error messages with actionable guidance
- Confirm destructive actions before executing

### Internationalization
- Design for internationalization from the start
- Use i18n libraries for text content
- Support RTL languages where applicable
- Format dates, times, and numbers according to locale

## Performance Requirements

### Load Time
- Initial page load: < 2 seconds on 3G connection
- Time to Interactive (TTI): < 3 seconds
- First Contentful Paint (FCP): < 1 second
- Largest Contentful Paint (LCP): < 2.5 seconds

### Runtime Performance
- Maintain 60 FPS during scrolling and animations
- Response to user input: < 100ms
- Avoid blocking the main thread for > 50ms
- Use Web Workers for CPU-intensive operations

### Network Efficiency
- Minimize bundle size (target: < 200KB initial bundle gzipped)
- Implement code splitting and lazy loading
- Use efficient image formats (WebP, AVIF) with fallbacks
- Implement proper caching strategies
- Minimize number of HTTP requests

### Memory Management
- Monitor and prevent memory leaks
- Clean up event listeners and subscriptions
- Optimize large lists with virtualization
- Implement pagination for large datasets
- Profile memory usage regularly

### Database Performance
- Index frequently queried fields
- Optimize complex queries
- Implement query result caching where appropriate
- Monitor and optimize slow queries (> 100ms)
- Use connection pooling

### Monitoring
- Implement performance monitoring in production
- Set up alerts for performance degradation
- Track Core Web Vitals
- Monitor error rates and types
- Measure and optimize Time to First Byte (TTFB)

## Code Review Standards

### Review Process
- All code must be reviewed by at least one other developer
- Address all review comments before merging
- Approve only when code meets all constitution principles
- Check for adherence to style guide and linting rules

### Review Focus Areas
- Correctness and logic errors
- Security vulnerabilities
- Performance implications
- Test coverage and quality
- Code readability and maintainability
- Accessibility compliance

## Documentation Standards

### Code Documentation
- Document all public APIs with JSDoc/TSDoc
- Include usage examples for complex functions
- Document non-obvious architectural decisions
- Keep README files up to date
- Maintain changelog for version tracking

### Architecture Documentation
- Document system architecture and major components
- Maintain up-to-date diagrams for complex systems
- Document API contracts and interfaces
- Explain design decisions and trade-offs
